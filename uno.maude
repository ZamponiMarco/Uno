fmod CARD is

	sorts Card Color Type .
	
	ops red green yellow blue all : -> Color [ctor] .
	ops 0 1 2 3 4 5 6 7 8 9 reverse stop plus2 plus4 change : -> Type [ctor] .
	op card : Type Color -> Card [ctor] .
	
	var Ca : Card .
	var T : Type .
	var C : Color .
	
	op getType : Card -> Type .
	eq getType(card(T, C)) = T .
	
	op getColor : Card -> Color .
	eq getColor(card(T,C)) = C .
	
	op isAction : Card -> Bool .
	eq isAction(Ca) = getType(Ca) == reverse or getType(Ca) == stop or  getType(Ca) == plus2 or  getType(Ca) == plus4 or getType(Ca) == change .
	
	op isNumber : Card -> Bool .
	eq isNumber(Ca) = not isAction(Ca) .
endfm

fmod DECK is 

	pr CARD .
	pr NAT .
	
	sort Deck .
	subsort Card < Deck .
	
	var D : Deck .
	var C : Card .
	
	op > : -> Deck [ctor] .
	op _|_ : Deck Deck -> Deck [assoc] .
	
	op example : -> Deck .
	eq example = card(0, red) | card(1, red) | card(2, red) .
	
	op insertFirst : Deck Card -> Deck .
	eq insertFirst(D, C) = C | D .
	
	op seeFirst : Deck -> Card .
	eq seeFirst((C | D)) = C .
	
	op removeFirst : Deck -> Deck .
	eq removeFirst((C | D)) = D .
	
	op |_| : Deck -> Nat .
	eq | D | = $c(D) .
	
	op $c : Deck -> Nat .
	eq $c((C | D)) = 1 + $c(D) .
	eq $c(C) = 1 .

endfm

fmod HAND is 

	pr DECK .
	
	sort Hand .
	subsort Card < Hand .
	
	op empty : -> Hand [ctor] .
	op _~_ : Hand Hand -> Hand [assoc comm] .
	
	var H : Hand .
	var C : Card .
	var R G B Y : Nat .
	
	op exampleHand : -> Hand .
	eq exampleHand = card(plus2, green) ~ card(plus2, green) ~ card(1,red) ~ card(plus2, yellow) ~ card(2,blue) ~ empty .
	
	op containsPlusTwo : Hand -> Bool .
	ceq containsPlusTwo(C ~ H) = true if getType(C) == plus2 .
	eq containsPlusTwo(C ~ H) = containsPlusTwo(H) . 
	eq containsPlusTwo(H) = getType(H) == plus2 .
	
	op getMostFrequentColor : Hand -> Color .
	eq getMostFrequentColor(H) = $gmfc(H, 0, 0, 0, 0) .
	
	op $gmfc : Hand Nat Nat Nat Nat -> Color .
	ceq $gmfc(H, R, G, B, Y) = red if H == empty and R >= G and R >= B and R >= Y .
	ceq $gmfc(H, R, G, B, Y) = green if H == empty and G >= R and G >= B and G >= Y .
	ceq $gmfc(H, R, G, B, Y) = blue if H == empty and B >= R and B >= G and B >= Y .
	ceq $gmfc(H, R, G, B, Y) = yellow if H == empty and Y >= R and Y >= G and Y >= B .
	ceq $gmfc(C ~ H, R, G, B, Y) = $gmfc(H, R + 1, G, B, Y) if getColor(C) == red .
	ceq $gmfc(C ~ H, R, G, B, Y) = $gmfc(H, R, G + 1, B, Y) if getColor(C) == green .
	ceq $gmfc(C ~ H, R, G, B, Y) = $gmfc(H, R, G, B + 1, Y) if getColor(C) == blue .
	ceq $gmfc(C ~ H, R, G, B, Y) = $gmfc(H, R, G, B, Y + 1) if getColor(C) == yellow .
	ceq $gmfc(C ~ H, R, G, B, Y) = $gmfc(H, R, G, B, Y) if getColor(C) == all .
	
endfm

mod GAME is

	pr HAND .
	pr INT .

	sort Game .
	
	op game : Hand Hand Hand Deck Deck Bool Bool Int Bool -> Game [ctor] . 
	
	op exampleGame : -> Game .
	eq exampleGame = game(
			(card(stop,red) ~ card(1,yellow) ~ card(1,yellow)) ~ empty,
			(card(stop,blue) ~ card(2,red) ~ card(2,red)) ~ empty,
			(card(stop,red) ~ card(3,red) ~ card(3,red)) ~ empty,
			(card(4,red) | card(4,blue) | card(4,yellow) | card(8,red) | card(8,blue) | card(8,yellow) | card(9,red) | card(9,blue) | card(9,yellow)) | >,
			(card(5,red)) | >,
			false, false, 0, false
		) .
	
	vars A B C : Hand .
	var Cou : Int .
	vars D G : Deck .
	vars P P' P'' : Bool .
	vars Ca Ca' : Card .
	var H : Hand .
	vars Col Col' : Color .
	vars T T' : Type .
	
	op getCurrentPlayer : Game -> Hand .
	eq getCurrentPlayer(game(A,B,C,D,G,P,P',Cou, P'')) = A .
	
	op possibleMove : Hand Card -> Bool .
	ceq possibleMove(Ca ~ H, Ca') = true if getColor(Ca) == getColor(Ca') or getType(Ca) == getType(Ca') or getColor(Ca) == all .
	ceq possibleMove(H, Ca') = false if H == empty .
	eq possibleMove(Ca ~ H, Ca') = possibleMove(H, Ca') .
	
	crl [activate-plustwo-draw] :
		game(A,B,C,D,(card(plus2, Col) | G), false, false, Cou, false) => game(A,B,C,D,(card(plus2, Col) | G),false, false, Cou, true) 
			if not containsPlusTwo(A) .
				
	crl [draw-two] :
		game(A,B,C,(Ca | Ca' | D), G, false, false, Cou, true) => game(Ca ~ Ca' ~ A,B,C,D,G,false, false, Cou - 2, true) 
			if Cou > 0 .
			
	rl [deactivate-plustwo-draw] :
		game(A,B,C,D,G, false, false, 0, true) => game(A,B,C,D,G,false, false, 0, false) .
	
	rl [throw-color] :
		game(card(T, Col) ~ H, B, C, D, (card(T', Col) | G), false, P, 0, false) => game(H, B, C, D, (card(T, Col) | card(T', Col) | G), true, P, 0, false) .
	
	rl [throw-type] :
		game(card(T, Col) ~ H, B, C, D, (card(T, Col') | G), false, P, 0, false) => game(H, B, C, D, (card(T, Col) | card(T, Col') | G), true, P, 0, false) .
		
	rl [throw-changecolor] :
		game(card(change, all) ~ H, B, C, D, G, false, P, 0, false) => game(H, B, C, D, (card(change, getMostFrequentColor(H)) | G), true, P, 0, false) .
		
	rl [throw-plusfour] :
		game(card(plus4, all) ~ H, B, C, D, G, false, P, 0, false) => game(B, C, H, D, card(plus4, getMostFrequentColor(H)) | G, false, false, 4, true) .
		
	rl [turn-action-plustwo-on-general] :
		game(A,B,C,D,(card(plus2, Col) | G), true, P, Cou, false) => game(B,C,A,D,(card(plus2, Col) | G), false, false,Cou + 2, false) .
		
	crl [turn-action-plustwo-on-plustwo] :
		game(card(plus2, Col) ~ A,B,C,D,(Ca | G), P, false, Cou, false) => game(B,C,A,D,(card(plus2, Col) | Ca | G),false, false, Cou + 2, false) 
			if getType(Ca) == plus2 .
		
	crl [turn-action-reverse] :
		game(A,B,C,D,(Ca | G), true, P, 0, false) => game(C,B,A,D,(Ca | G),false, false, 0, false) 
			if getType(Ca) == reverse .
		
	crl [turn-action-stop-cumulative] :
		game(A,(Ca' ~ B),C,D,(Ca | G), true, P, 0,false) => game(B,C,A,D,(Ca' | Ca | G), true, false, 0,false) 
			if getType(Ca) == stop and getType(Ca') == stop .
		
	crl [turn-action-stop] :
		game(A,(Ca' ~ B),C,D,(Ca | G), true, P, 0,false) => game(C,A,B,D,(Ca | G),false, false, 0,false) 
			if getType(Ca) == stop and not getType(Ca') == stop .
		
	crl [turn-number] :
		game(A,B,C,D,(Ca | G), true, P, 0,false) => game(B,C,A,D,(Ca | G),false, false, 0,false) 
			if isNumber(Ca) or getType(Ca) == change .
		
	crl [draw] :
		game(A, B, C, (Ca | D), (Ca' | G), false, false, 0 ,false) => game(A ~ Ca, B, C, D, (Ca' | G), false, true, 0, false) 
			if not possibleMove(A, Ca') .

endm